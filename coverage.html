
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>image-fetcher: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">image-processing-system/cmd/image-fetcher/main.go (0.0%)</option>
				
				<option value="file1">image-processing-system/cmd/image-metadata/main.go (0.0%)</option>
				
				<option value="file2">image-processing-system/cmd/url-ingestor/main.go (0.0%)</option>
				
				<option value="file3">image-processing-system/internal/config/config.go (0.0%)</option>
				
				<option value="file4">image-processing-system/internal/config/image_fetcher.go (0.0%)</option>
				
				<option value="file5">image-processing-system/internal/config/image_metadata.go (0.0%)</option>
				
				<option value="file6">image-processing-system/internal/config/url_ingestor.go (0.0%)</option>
				
				<option value="file7">image-processing-system/internal/handler/router.go (76.3%)</option>
				
				<option value="file8">image-processing-system/internal/middleware/cors.go (0.0%)</option>
				
				<option value="file9">image-processing-system/internal/middleware/logging.go (0.0%)</option>
				
				<option value="file10">image-processing-system/internal/middleware/metrics.go (0.0%)</option>
				
				<option value="file11">image-processing-system/internal/middleware/prometheus.go (0.0%)</option>
				
				<option value="file12">image-processing-system/internal/middleware/response_writer.go (0.0%)</option>
				
				<option value="file13">image-processing-system/internal/service/metadata/store.go (0.0%)</option>
				
				<option value="file14">image-processing-system/internal/service/processor/processor.go (27.8%)</option>
				
				<option value="file15">image-processing-system/internal/service/storage/minio.go (0.0%)</option>
				
				<option value="file16">image-processing-system/internal/worker/consumer.go (0.0%)</option>
				
				<option value="file17">image-processing-system/pkg/message/codec.go (0.0%)</option>
				
				<option value="file18">image-processing-system/pkg/rabbitmq/conn.go (0.0%)</option>
				
				<option value="file19">image-processing-system/pkg/tracing/tracing.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "image-processing-system/internal/config"
        "image-processing-system/internal/worker"
        "image-processing-system/pkg/rabbitmq"
        "image-processing-system/pkg/tracing"
        "log"
)

func main() <span class="cov0" title="0">{
        // Load configuration
        cfg := config.LoadImageFetcherConfig()

        // Initialize tracing
        tracer := tracing.Init("image-fetcher")
        defer tracer.Shutdown(context.Background())

        // Connect to RabbitMQ
        conn, ch := rabbitmq.Connect()
        defer conn.Close()
        defer ch.Close()

        // Create and start worker
        imageWorker, err := worker.NewImageWorker(cfg, ch)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create image worker: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("image-fetcher service starting...")
        imageWorker.Start()</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "image-processing-system/internal/config"
        "image-processing-system/internal/service/metadata"
        "image-processing-system/pkg/rabbitmq"
        "image-processing-system/pkg/tracing"
        "log"
        "net/http"

        "github.com/prometheus/client_golang/prometheus/promhttp"
)

func main() <span class="cov0" title="0">{
        // Load configuration
        cfg := config.LoadImageMetadataConfig()

        // Initialize tracing
        tracer := tracing.Init("image-metadata")
        defer tracer.Shutdown(context.Background())

        // Start metrics server if enabled
        if cfg.Metrics.Enabled </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        mux := http.NewServeMux()
                        mux.Handle(cfg.Metrics.Path, promhttp.Handler())
                        mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                                w.Header().Set("Content-Type", "application/json")
                                w.Write([]byte(`{"status":"healthy","service":"image-metadata"}`))
                        }</span>)

                        <span class="cov0" title="0">metricsServer := &amp;http.Server{
                                Addr:    ":" + cfg.Metrics.Port,
                                Handler: mux,
                        }

                        log.Printf("Metrics server listening on :%s", cfg.Metrics.Port)
                        if err := metricsServer.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                                log.Printf("Metrics server error: %v", err)
                        }</span>
                }()
        }

        // Create metadata service
        <span class="cov0" title="0">metadataSvc, err := metadata.NewMetadataService(cfg.Database)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create metadata service: %v", err)
        }</span>

        // Connect to RabbitMQ
        <span class="cov0" title="0">conn, ch := rabbitmq.Connect()
        defer conn.Close()
        defer ch.Close()

        log.Println("image-metadata service consuming processed image queue")
        if cfg.Metrics.Enabled </span><span class="cov0" title="0">{
                log.Printf("Metrics server available on :%s%s", cfg.Metrics.Port, cfg.Metrics.Path)
        }</span>
        <span class="cov0" title="0">metadataSvc.ConsumeAndStore(ch)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "image-processing-system/internal/config"
        "image-processing-system/internal/handler"
        "image-processing-system/internal/middleware"
        "image-processing-system/pkg/rabbitmq"
        "image-processing-system/pkg/tracing"
        "log"
        "net/http"

        "github.com/prometheus/client_golang/prometheus/promhttp"
        amqp "github.com/rabbitmq/amqp091-go"
)

// AMQPChannelAdapter adapts amqp.Channel to implement ChannelInterface
type AMQPChannelAdapter struct {
        *amqp.Channel
}

func (a *AMQPChannelAdapter) IsClosed() bool <span class="cov0" title="0">{
        return a.Channel.IsClosed()
}</span>

func main() <span class="cov0" title="0">{
        // Load configuration
        cfg := config.LoadURLIngestorConfig()

        // Initialize tracing
        tracer := tracing.Init("url-ingestor")
        defer tracer.Shutdown(context.Background())

        // Connect to RabbitMQ
        conn, ch := rabbitmq.Connect()
        defer conn.Close()
        defer ch.Close()

        // Create adapter for the channel
        channelAdapter := &amp;AMQPChannelAdapter{Channel: ch}

        // Start metrics server if enabled
        if cfg.Metrics.Enabled </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        mux := http.NewServeMux()
                        mux.Handle(cfg.Metrics.Path, promhttp.Handler())
                        mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                                w.Header().Set("Content-Type", "application/json")
                                w.Write([]byte(`{"status":"healthy","service":"url-ingestor"}`))
                        }</span>)

                        <span class="cov0" title="0">metricsServer := &amp;http.Server{
                                Addr:    ":" + cfg.Metrics.Port,
                                Handler: mux,
                        }

                        log.Printf("Metrics server listening on :%s", cfg.Metrics.Port)
                        if err := metricsServer.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                                log.Printf("Metrics server error: %v", err)
                        }</span>
                }()
        }

        // Create router with middleware
        <span class="cov0" title="0">router := handler.NewRouter(channelAdapter)

        // Add middleware - ensure metrics endpoint is accessible
        handler := middleware.LoggingMiddleware(router)
        handler = middleware.CORSMiddleware(handler)

        // Create server
        srv := &amp;http.Server{
                Addr:    ":" + cfg.Server.Port,
                Handler: handler,
        }

        log.Printf("url-ingestor listening on :%s", cfg.Server.Port)
        log.Printf("Available endpoints:")
        log.Printf("  - POST /submit (submit images)")
        log.Printf("  - GET /health (health check)")
        log.Printf("  - GET /status (service status)")
        log.Printf("  - GET /queue/status (queue status)")
        log.Printf("  - GET /stats (system stats)")
        log.Printf("  - GET /metrics (Prometheus metrics)")

        if cfg.Metrics.Enabled </span><span class="cov0" title="0">{
                log.Printf("Metrics server available on :%s%s", cfg.Metrics.Port, cfg.Metrics.Path)
        }</span>

        <span class="cov0" title="0">log.Fatal(srv.ListenAndServe())</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package config

import (
        "os"
        "strconv"
)

// Config holds all application configuration
type Config struct {
        Server   ServerConfig
        Database DatabaseConfig
        Minio    MinioConfig
        RabbitMQ RabbitMQConfig
        Metrics  MetricsConfig
}

// ServerConfig holds HTTP server configuration
type ServerConfig struct {
        Port string
}

// DatabaseConfig holds database configuration
type DatabaseConfig struct {
        Host     string
        Port     string
        User     string
        Password string
        DBName   string
        SSLMode  string
}

// MinioConfig holds MinIO configuration
type MinioConfig struct {
        Endpoint  string
        AccessKey string
        SecretKey string
        UseSSL    bool
        Bucket    string
}

// RabbitMQConfig holds RabbitMQ configuration
type RabbitMQConfig struct {
        URL string
}

// MetricsConfig holds Prometheus metrics configuration
type MetricsConfig struct {
        Enabled bool
        Port    string
        Path    string
}

// getEnv gets an environment variable or returns a default value
func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

// getEnvAsBool gets an environment variable as boolean or returns a default value
func getEnvAsBool(key string, defaultValue bool) bool <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if boolValue, err := strconv.ParseBool(value); err == nil </span><span class="cov0" title="0">{
                        return boolValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

// ImageFetcherConfig holds configuration specific to image-fetcher service
type ImageFetcherConfig struct {
        RabbitMQ RabbitMQConfig
        Minio    MinioConfig
        Database DatabaseConfig
        Metrics  MetricsConfig
}

// LoadImageFetcherConfig loads configuration for image-fetcher service
func LoadImageFetcherConfig() *ImageFetcherConfig <span class="cov0" title="0">{
        return &amp;ImageFetcherConfig{
                RabbitMQ: RabbitMQConfig{
                        URL: getEnv("RABBITMQ_URL", "amqp://guest:guest@rabbitmq:5672/"),
                },
                Minio: MinioConfig{
                        Endpoint:  getEnv("MINIO_ENDPOINT", "minio:9000"),
                        AccessKey: getEnv("MINIO_ACCESS_KEY", "minioadmin"),
                        SecretKey: getEnv("MINIO_SECRET_KEY", "minioadmin"),
                        UseSSL:    getEnvAsBool("MINIO_USE_SSL", false),
                        Bucket:    getEnv("MINIO_BUCKET", "images"),
                },
                Database: DatabaseConfig{
                        Host:     getEnv("DB_HOST", "postgres"),
                        Port:     getEnv("DB_PORT", "5432"),
                        User:     getEnv("DB_USER", "postgres"),
                        Password: getEnv("DB_PASSWORD", "postgres"),
                        DBName:   getEnv("DB_NAME", "images"),
                        SSLMode:  getEnv("DB_SSLMODE", "disable"),
                },
                Metrics: MetricsConfig{
                        Enabled: getEnvAsBool("METRICS_ENABLED", true),
                        Port:    getEnv("METRICS_PORT", "8081"),
                        Path:    getEnv("METRICS_PATH", "/metrics"),
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package config

// ImageMetadataConfig holds configuration specific to image-metadata service
type ImageMetadataConfig struct {
        RabbitMQ RabbitMQConfig
        Database DatabaseConfig
        Metrics  MetricsConfig
}

// LoadImageMetadataConfig loads configuration for image-metadata service
func LoadImageMetadataConfig() *ImageMetadataConfig <span class="cov0" title="0">{
        return &amp;ImageMetadataConfig{
                RabbitMQ: RabbitMQConfig{
                        URL: getEnv("RABBITMQ_URL", "amqp://guest:guest@rabbitmq:5672/"),
                },
                Database: DatabaseConfig{
                        Host:     getEnv("DB_HOST", "postgres"),
                        Port:     getEnv("DB_PORT", "5432"),
                        User:     getEnv("DB_USER", "postgres"),
                        Password: getEnv("DB_PASSWORD", "postgres"),
                        DBName:   getEnv("DB_NAME", "images"),
                        SSLMode:  getEnv("DB_SSLMODE", "disable"),
                },
                Metrics: MetricsConfig{
                        Enabled: getEnvAsBool("METRICS_ENABLED", true),
                        Port:    getEnv("METRICS_PORT", "8082"),
                        Path:    getEnv("METRICS_PATH", "/metrics"),
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package config

// URLIngestorConfig holds configuration specific to url-ingestor service
type URLIngestorConfig struct {
        Server   ServerConfig
        RabbitMQ RabbitMQConfig
        Metrics  MetricsConfig
}

// LoadURLIngestorConfig loads configuration for url-ingestor service
func LoadURLIngestorConfig() *URLIngestorConfig <span class="cov0" title="0">{
        return &amp;URLIngestorConfig{
                Server: ServerConfig{
                        Port: getEnv("SERVER_PORT", "8080"),
                },
                RabbitMQ: RabbitMQConfig{
                        URL: getEnv("RABBITMQ_URL", "amqp://guest:guest@rabbitmq:5672/"),
                },
                Metrics: MetricsConfig{
                        Enabled: getEnvAsBool("METRICS_ENABLED", true),
                        Port:    getEnv("METRICS_PORT", "8083"),
                        Path:    getEnv("METRICS_PATH", "/metrics"),
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package handler

import (
        "encoding/json"
        "net/http"
        "time"

        "image-processing-system/internal/middleware"
        "image-processing-system/internal/models"
        "image-processing-system/pkg/message"

        "github.com/go-chi/chi/v5"
        "github.com/go-chi/httprate"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        amqp "github.com/rabbitmq/amqp091-go"
)

// ChannelInterface defines the interface for RabbitMQ channels
type ChannelInterface interface {
        Publish(exchange, key string, mandatory, immediate bool, msg amqp.Publishing) error
        IsClosed() bool
        Close() error
}

var (
        imagesSubmitted = prometheus.NewCounter(
                prometheus.CounterOpts{
                        Name: "images_submitted_total",
                        Help: "Total number of images submitted for processing",
                },
        )
)

func init() <span class="cov8" title="1">{
        prometheus.MustRegister(imagesSubmitted)
}</span>

func NewRouter(ch ChannelInterface) http.Handler <span class="cov8" title="1">{
        r := chi.NewRouter()

        // Add rate limiting middleware
        r.Use(httprate.LimitByIP(50, 1)) // 50 req/sec

        // Add Prometheus metrics middleware
        r.Use(middleware.MetricsMiddleware)

        // Health check - no middleware applied
        r.Get("/health", func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "status":    "healthy",
                        "timestamp": time.Now().UTC(),
                        "service":   "url-ingestor",
                })
        }</span>)

        // Metrics endpoint - no middleware applied to avoid conflicts
        <span class="cov8" title="1">r.Get("/metrics", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                promhttp.Handler().ServeHTTP(w, r)
        }</span>)

        // Status endpoint
        <span class="cov8" title="1">r.Get("/status", func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                // Check RabbitMQ connection
                rabbitmqStatus := "healthy"
                if ch == nil || ch.IsClosed() </span><span class="cov0" title="0">{
                        rabbitmqStatus = "unhealthy"
                }</span>

                <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "service":   "url-ingestor",
                        "status":    "running",
                        "timestamp": time.Now().UTC(),
                        "dependencies": map[string]string{
                                "rabbitmq": rabbitmqStatus,
                        },
                })</span>
        })

        // Queue status endpoint
        <span class="cov8" title="1">r.Get("/queue/status", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if ch == nil || ch.IsClosed() </span><span class="cov0" title="0">{
                        http.Error(w, "RabbitMQ connection not available", http.StatusServiceUnavailable)
                        return
                }</span>

                // Get queue info - this would need to be handled differently for mocks
                // For now, we'll skip this in tests
                <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "queue_name": "image.urls",
                        "messages":   0,
                        "consumers":  0,
                        "timestamp":  time.Now().UTC(),
                })</span>
        })

        // System statistics endpoint
        <span class="cov8" title="1">r.Get("/stats", func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "service":   "url-ingestor",
                        "timestamp": time.Now().UTC(),
                        "metrics": map[string]interface{}{
                                "endpoints": map[string]string{
                                        "health":  "/health",
                                        "status":  "/status",
                                        "queue":   "/queue/status",
                                        "metrics": "/metrics",
                                        "submit":  "/submit",
                                },
                        },
                })
        }</span>)

        <span class="cov8" title="1">r.Post("/submit", func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                var job models.ImageJob
                if err := json.NewDecoder(r.Body).Decode(&amp;job); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusBadRequest)
                        return
                }</span>

                // Increment metrics
                <span class="cov8" title="1">imagesSubmitted.Add(float64(len(job.URLs)))

                traceID := r.Header.Get("X-Trace-ID")
                encoded, _ := message.Encode(traceID, "url-ingestor", job)

                err := ch.Publish("", "image.urls", false, false, amqp.Publishing{
                        ContentType: "application/json",
                        Body:        encoded,
                })
                if err != nil </span><span class="cov8" title="1">{
                        http.Error(w, "publish failed", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">w.WriteHeader(http.StatusAccepted)</span>
        })

        <span class="cov8" title="1">return r</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package middleware

import "net/http"

// CORSMiddleware handles Cross-Origin Resource Sharing
func CORSMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Set CORS headers
                w.Header().Set("Access-Control-Allow-Origin", "*")
                w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                w.Header().Set("Access-Control-Allow-Headers", "Accept, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, X-Trace-ID")

                // Handle preflight requests
                if r.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusOK)
                        return
                }</span>

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package middleware

import (
        "log"
        "net/http"
        "time"
)

// LoggingMiddleware logs HTTP requests with timing information
func LoggingMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()

                // Create a response writer wrapper to capture status code
                wrapped := NewResponseWriter(w)

                next.ServeHTTP(wrapped, r)

                duration := time.Since(start)
                log.Printf(
                        "%s %s %s %d %v",
                        r.Method,
                        r.RequestURI,
                        r.RemoteAddr,
                        wrapped.StatusCode(),
                        duration,
                )
        }</span>)
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package middleware

import (
        "net/http"
        "strconv"
        "time"

        "github.com/prometheus/client_golang/prometheus"
)

var (
        httpRequestsTotal = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "http_requests_total",
                        Help: "Total number of HTTP requests",
                },
                []string{"method", "endpoint", "status"},
        )

        httpRequestDuration = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "http_request_duration_seconds",
                        Help:    "HTTP request duration in seconds",
                        Buckets: prometheus.DefBuckets,
                },
                []string{"method", "endpoint"},
        )

        httpRequestsInFlight = prometheus.NewGauge(
                prometheus.GaugeOpts{
                        Name: "http_requests_in_flight",
                        Help: "Current number of HTTP requests being processed",
                },
        )
)

func init() <span class="cov0" title="0">{
        prometheus.MustRegister(httpRequestsTotal)
        prometheus.MustRegister(httpRequestDuration)
        prometheus.MustRegister(httpRequestsInFlight)
}</span>

// MetricsMiddleware collects Prometheus metrics for HTTP requests
func MetricsMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()

                // Increment in-flight requests
                httpRequestsInFlight.Inc()
                defer httpRequestsInFlight.Dec()

                // Create a response writer wrapper to capture status code
                wrapped := NewResponseWriter(w)

                next.ServeHTTP(wrapped, r)

                duration := time.Since(start).Seconds()

                // Record metrics
                httpRequestsTotal.WithLabelValues(
                        r.Method,
                        r.URL.Path,
                        strconv.Itoa(wrapped.StatusCode()),
                ).Inc()

                httpRequestDuration.WithLabelValues(
                        r.Method,
                        r.URL.Path,
                ).Observe(duration)
        }</span>)
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package middleware

import (
        "github.com/prometheus/client_golang/prometheus"
)

// WorkerMetrics holds all worker-related Prometheus metrics
var (
        // Image processing metrics
        ImagesProcessed = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "images_processed_total",
                        Help: "Total number of images processed",
                },
                []string{"status", "service"},
        )

        ProcessingDuration = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "image_processing_duration_seconds",
                        Help:    "Image processing duration in seconds",
                        Buckets: prometheus.DefBuckets,
                },
                []string{"step", "service"},
        )

        // Queue metrics
        QueueSize = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "queue_size",
                        Help: "Current size of the processing queue",
                },
                []string{"queue_name", "service"},
        )

        ActiveWorkers = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "active_workers",
                        Help: "Number of currently active workers",
                },
                []string{"service"},
        )

        // Job processing metrics
        JobsProcessed = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "jobs_processed_total",
                        Help: "Total number of jobs processed",
                },
                []string{"status", "service"},
        )

        JobProcessingDuration = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "job_processing_duration_seconds",
                        Help:    "Job processing duration in seconds",
                        Buckets: prometheus.DefBuckets,
                },
                []string{"service"},
        )
)

func init() <span class="cov0" title="0">{
        // Register all worker metrics
        prometheus.MustRegister(ImagesProcessed)
        prometheus.MustRegister(ProcessingDuration)
        prometheus.MustRegister(QueueSize)
        prometheus.MustRegister(ActiveWorkers)
        prometheus.MustRegister(JobsProcessed)
        prometheus.MustRegister(JobProcessingDuration)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package middleware

import "net/http"

// ResponseWriter wraps http.ResponseWriter to capture status code
type ResponseWriter struct {
        http.ResponseWriter
        statusCode int
}

// NewResponseWriter creates a new response writer wrapper
func NewResponseWriter(w http.ResponseWriter) *ResponseWriter <span class="cov0" title="0">{
        return &amp;ResponseWriter{ResponseWriter: w, statusCode: http.StatusOK}
}</span>

// WriteHeader captures the status code
func (rw *ResponseWriter) WriteHeader(code int) <span class="cov0" title="0">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</span>

// Write delegates to the underlying ResponseWriter
func (rw *ResponseWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        return rw.ResponseWriter.Write(b)
}</span>

// StatusCode returns the captured status code
func (rw *ResponseWriter) StatusCode() int <span class="cov0" title="0">{
        return rw.statusCode
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package metadata

import (
        "fmt"
        "log"
        "net/http"
        "time"

        "image-processing-system/internal/config"
        "image-processing-system/pkg/message"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        amqp "github.com/rabbitmq/amqp091-go"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

var (
        recordsStored = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "records_stored_total",
                        Help: "Total number of records stored in database",
                },
                []string{"status"},
        )

        storageDuration = prometheus.NewHistogram(
                prometheus.HistogramOpts{
                        Name:    "storage_duration_seconds",
                        Help:    "Database storage operation duration in seconds",
                        Buckets: prometheus.DefBuckets,
                },
        )

        dbConnections = prometheus.NewGauge(
                prometheus.GaugeOpts{
                        Name: "db_connections_active",
                        Help: "Number of active database connections",
                },
        )
)

func init() <span class="cov0" title="0">{
        prometheus.MustRegister(recordsStored)
        prometheus.MustRegister(storageDuration)
        prometheus.MustRegister(dbConnections)
}</span>

// ImageRecord represents an image processing record in the database
type ImageRecord struct {
        ID          uint `gorm:"primaryKey"`
        SourceURL   string
        S3Path      string
        ProcessedAt time.Time
        Status      string
        ErrorMsg    string
        TraceID     string
}

// ImageProcessedPayload represents the payload for processed image messages
type ImageProcessedPayload struct {
        SourceURL string `json:"source_url"`
        S3Path    string `json:"s3_path"`
        Status    string `json:"status"` // success/error
        ErrorMsg  string `json:"error_msg,omitempty"`
        TraceID   string `json:"trace_id"`
}

// MetadataService handles metadata operations
type MetadataService struct {
        db            *gorm.DB
        metricsServer *http.Server
}

// NewMetadataService creates a new metadata service instance
func NewMetadataService(cfg config.DatabaseConfig) (*MetadataService, error) <span class="cov0" title="0">{
        // Use a more compatible connection string format for PostgreSQL 17
        dsn := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=%s connect_timeout=10",
                cfg.Host, cfg.Port, cfg.User, cfg.Password, cfg.DBName, cfg.SSLMode)

        db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{
                // Add connection pool settings for better stability
                DisableForeignKeyConstraintWhenMigrating: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        // Get the underlying sql.DB to configure connection pool
        <span class="cov0" title="0">sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get underlying sql.DB: %w", err)
        }</span>

        // Configure connection pool settings
        <span class="cov0" title="0">sqlDB.SetMaxIdleConns(10)
        sqlDB.SetMaxOpenConns(100)
        sqlDB.SetConnMaxLifetime(time.Hour)

        // Auto migrate the schema
        if err := db.AutoMigrate(&amp;ImageRecord{}); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to migrate database: %w", err)
        }</span>

        // Start metrics server
        <span class="cov0" title="0">mux := http.NewServeMux()
        mux.Handle("/metrics", promhttp.Handler())
        mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                w.Write([]byte(`{"status":"healthy","service":"image-metadata"}`))
        }</span>)

        <span class="cov0" title="0">metricsServer := &amp;http.Server{
                Addr:    ":8082",
                Handler: mux,
        }

        go func() </span><span class="cov0" title="0">{
                if err := metricsServer.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Printf("Metrics server error: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">return &amp;MetadataService{db: db, metricsServer: metricsServer}, nil</span>
}

// ConsumeAndStore processes messages and stores metadata
func (m *MetadataService) ConsumeAndStore(ch *amqp.Channel) <span class="cov0" title="0">{
        msgs, err := ch.Consume("image.processed", "", true, false, false, false, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to consume messages: %v", err)
                return
        }</span>

        <span class="cov0" title="0">for msg := range msgs </span><span class="cov0" title="0">{
                start := time.Now()

                env, payload, err := message.Decode[ImageProcessedPayload](msg.Body)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to decode message: %v", err)
                        recordsStored.WithLabelValues("decode_error").Inc()
                        continue</span>
                }

                <span class="cov0" title="0">record := ImageRecord{
                        SourceURL:   payload.SourceURL,
                        S3Path:      payload.S3Path,
                        ProcessedAt: env.Timestamp,
                        Status:      payload.Status,
                        ErrorMsg:    payload.ErrorMsg,
                        TraceID:     payload.TraceID,
                }

                if err := m.db.Create(&amp;record).Error; err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to save record to database: %v", err)
                        recordsStored.WithLabelValues("error").Inc()
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("Saved image record: %s -&gt; %s", payload.SourceURL, payload.S3Path)
                        recordsStored.WithLabelValues("success").Inc()
                }</span>

                <span class="cov0" title="0">storageDuration.Observe(time.Since(start).Seconds())</span>
        }
}

// GetImageRecords retrieves image records from the database
func (m *MetadataService) GetImageRecords(limit int) ([]ImageRecord, error) <span class="cov0" title="0">{
        var records []ImageRecord
        err := m.db.Order("processed_at DESC").Limit(limit).Find(&amp;records).Error
        return records, err
}</span>

// GetImageRecordByID retrieves a specific image record by ID
func (m *MetadataService) GetImageRecordByID(id uint) (*ImageRecord, error) <span class="cov0" title="0">{
        var record ImageRecord
        err := m.db.First(&amp;record, id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;record, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package processor

import (
        "context"
        "fmt"
        "image"
        "net/http"
        "time"

        "github.com/disintegration/imaging"
)

// ImageProcessor handles image processing operations
type ImageProcessor struct {
        client *http.Client
}

// NewImageProcessor creates a new image processor instance
func NewImageProcessor() *ImageProcessor <span class="cov8" title="1">{
        return &amp;ImageProcessor{
                client: &amp;http.Client{
                        Timeout: 30 * time.Second,
                },
        }
}</span>

// DownloadImage downloads an image from a URL
func (p *ImageProcessor) DownloadImage(ctx context.Context, url string) (image.Image, string, error) <span class="cov8" title="1">{
        req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, "", fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := p.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to download image: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("HTTP error: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">img, format, err := image.Decode(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to decode image: %w", err)
        }</span>

        <span class="cov0" title="0">return img, format, nil</span>
}

// Grayscale converts an image to grayscale
func (p *ImageProcessor) Grayscale(img image.Image) image.Image <span class="cov8" title="1">{
        return imaging.Grayscale(img)
}</span>

// Resize resizes an image to the specified dimensions
func (p *ImageProcessor) Resize(img image.Image, width, height int) image.Image <span class="cov0" title="0">{
        return imaging.Resize(img, width, height, imaging.Lanczos)
}</span>

// Blur applies a blur effect to an image
func (p *ImageProcessor) Blur(img image.Image, sigma float64) image.Image <span class="cov0" title="0">{
        return imaging.Blur(img, sigma)
}</span>

// Sharpen applies a sharpen effect to an image
func (p *ImageProcessor) Sharpen(img image.Image, sigma float64) image.Image <span class="cov0" title="0">{
        return imaging.Sharpen(img, sigma)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package storage

import (
        "bytes"
        "context"
        "fmt"
        "image"
        "image/jpeg"
        "log"
        "time"

        "image-processing-system/internal/config"

        "github.com/minio/minio-go/v7"
        "github.com/minio/minio-go/v7/pkg/credentials"
)

// MinioService handles MinIO operations
type MinioService struct {
        client *minio.Client
        config config.MinioConfig
}

// NewMinioService creates a new MinIO service instance
func NewMinioService(cfg config.MinioConfig) (*MinioService, error) <span class="cov0" title="0">{
        client, err := minio.New(cfg.Endpoint, &amp;minio.Options{
                Creds:  credentials.NewStaticV4(cfg.AccessKey, cfg.SecretKey, ""),
                Secure: cfg.UseSSL,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create MinIO client: %w", err)
        }</span>

        // Ensure bucket exists
        <span class="cov0" title="0">ctx := context.Background()
        exists, err := client.BucketExists(ctx, cfg.Bucket)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check bucket existence: %w", err)
        }</span>

        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                err = client.MakeBucket(ctx, cfg.Bucket, minio.MakeBucketOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create bucket: %w", err)
                }</span>
                <span class="cov0" title="0">log.Printf("Created MinIO bucket: %s", cfg.Bucket)</span>
        }

        <span class="cov0" title="0">return &amp;MinioService{
                client: client,
                config: cfg,
        }, nil</span>
}

// UploadImage uploads an image to MinIO
func (m *MinioService) UploadImage(ctx context.Context, img image.Image) (string, error) <span class="cov0" title="0">{
        buf := new(bytes.Buffer)
        if err := jpeg.Encode(buf, img, &amp;jpeg.Options{Quality: 90}); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to encode image: %w", err)
        }</span>

        <span class="cov0" title="0">filename := time.Now().Format("20060102150405") + ".jpg"
        _, err := m.client.PutObject(
                ctx,
                m.config.Bucket,
                filename,
                bytes.NewReader(buf.Bytes()),
                int64(buf.Len()),
                minio.PutObjectOptions{ContentType: "image/jpeg"},
        )
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to upload image: %w", err)
        }</span>

        <span class="cov0" title="0">return filename, nil</span>
}

// GetImageURL returns the full URL for an image
func (m *MinioService) GetImageURL(filename string) string <span class="cov0" title="0">{
        return fmt.Sprintf("s3://%s/%s", m.config.Bucket, filename)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package worker

import (
        "context"
        "log"
        "sync"
        "time"

        "image-processing-system/internal/config"
        "image-processing-system/internal/middleware"
        "image-processing-system/internal/models"
        "image-processing-system/internal/service/metadata"
        "image-processing-system/internal/service/processor"
        "image-processing-system/internal/service/storage"
        "image-processing-system/pkg/message"

        "net/http"

        "github.com/prometheus/client_golang/prometheus/promhttp"
        amqp "github.com/rabbitmq/amqp091-go"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
)

// ImageWorker handles image processing jobs
type ImageWorker struct {
        config           *config.ImageFetcherConfig
        processor        *processor.ImageProcessor
        storage          *storage.MinioService
        metadata         *metadata.MetadataService
        channel          *amqp.Channel
        concurrencyLimit int
        metricsServer    *http.Server
}

// NewImageWorker creates a new image worker instance
func NewImageWorker(cfg *config.ImageFetcherConfig, ch *amqp.Channel) (*ImageWorker, error) <span class="cov0" title="0">{
        proc := processor.NewImageProcessor()

        storageSvc, err := storage.NewMinioService(cfg.Minio)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">metadataSvc, err := metadata.NewMetadataService(cfg.Database)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Start metrics server if enabled
        <span class="cov0" title="0">var metricsServer *http.Server
        if cfg.Metrics.Enabled </span><span class="cov0" title="0">{
                mux := http.NewServeMux()
                mux.Handle(cfg.Metrics.Path, promhttp.Handler())
                mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        w.Header().Set("Content-Type", "application/json")
                        w.Write([]byte(`{"status":"healthy","service":"image-fetcher"}`))
                }</span>)

                <span class="cov0" title="0">metricsServer = &amp;http.Server{
                        Addr:    ":" + cfg.Metrics.Port,
                        Handler: mux,
                }

                go func() </span><span class="cov0" title="0">{
                        if err := metricsServer.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                                log.Printf("Metrics server error: %v", err)
                        }</span>
                }()
        }

        <span class="cov0" title="0">return &amp;ImageWorker{
                config:           cfg,
                processor:        proc,
                storage:          storageSvc,
                metadata:         metadataSvc,
                channel:          ch,
                concurrencyLimit: 5, // Can be made configurable
                metricsServer:    metricsServer,
        }, nil</span>
}

// Start begins consuming and processing image jobs
func (w *ImageWorker) Start() <span class="cov0" title="0">{
        msgs, err := w.channel.Consume("image.urls", "", true, false, false, false, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to consume messages: %v", err)
                return
        }</span>

        <span class="cov0" title="0">sem := make(chan struct{}, w.concurrencyLimit)
        var wg sync.WaitGroup

        for msg := range msgs </span><span class="cov0" title="0">{
                sem &lt;- struct{}{}
                wg.Add(1)
                middleware.ActiveWorkers.WithLabelValues("image-fetcher").Inc()

                go func(m amqp.Delivery) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        defer func() </span><span class="cov0" title="0">{
                                &lt;-sem
                                middleware.ActiveWorkers.WithLabelValues("image-fetcher").Dec()
                        }</span>()

                        <span class="cov0" title="0">w.processJob(m)</span>
                }(msg)
        }
        <span class="cov0" title="0">wg.Wait()</span>
}

// processJob processes a single image job
func (w *ImageWorker) processJob(msg amqp.Delivery) <span class="cov0" title="0">{
        start := time.Now()

        env, job, err := message.Decode[models.ImageJob](msg.Body)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to decode job: %v", err)
                middleware.JobsProcessed.WithLabelValues("decode_error", "image-fetcher").Inc()
                return
        }</span>

        <span class="cov0" title="0">ctx, span := otel.Tracer("worker").Start(context.Background(), "processJob")
        span.SetAttributes(attribute.String("trace_id", env.TraceID))
        defer span.End()

        successCount := 0
        errorCount := 0

        for _, url := range job.URLs </span><span class="cov0" title="0">{
                if err := w.processImage(ctx, url, env.TraceID); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to process image %s: %v", url, err)
                        errorCount++
                        // Continue processing other images in the job
                }</span> else<span class="cov0" title="0"> {
                        successCount++
                }</span>
        }

        // Record metrics
        <span class="cov0" title="0">middleware.ImagesProcessed.WithLabelValues("success", "image-fetcher").Add(float64(successCount))
        middleware.ImagesProcessed.WithLabelValues("error", "image-fetcher").Add(float64(errorCount))
        middleware.JobProcessingDuration.WithLabelValues("image-fetcher").Observe(time.Since(start).Seconds())</span>
}

// processImage processes a single image
func (w *ImageWorker) processImage(ctx context.Context, url, traceID string) error <span class="cov0" title="0">{
        // Download image
        downloadStart := time.Now()
        img, _, err := w.processor.DownloadImage(ctx, url)
        if err != nil </span><span class="cov0" title="0">{
                middleware.ProcessingDuration.WithLabelValues("download", "image-fetcher").Observe(time.Since(downloadStart).Seconds())
                return err
        }</span>
        <span class="cov0" title="0">middleware.ProcessingDuration.WithLabelValues("download", "image-fetcher").Observe(time.Since(downloadStart).Seconds())

        // Process image (convert to grayscale)
        processStart := time.Now()
        processedImg := w.processor.Grayscale(img)
        middleware.ProcessingDuration.WithLabelValues("grayscale", "image-fetcher").Observe(time.Since(processStart).Seconds())

        // Upload to storage
        uploadStart := time.Now()
        filename, err := w.storage.UploadImage(ctx, processedImg)
        if err != nil </span><span class="cov0" title="0">{
                middleware.ProcessingDuration.WithLabelValues("upload", "image-fetcher").Observe(time.Since(uploadStart).Seconds())
                return err
        }</span>
        <span class="cov0" title="0">middleware.ProcessingDuration.WithLabelValues("upload", "image-fetcher").Observe(time.Since(uploadStart).Seconds())

        // Create result payload
        result := metadata.ImageProcessedPayload{
                SourceURL: url,
                S3Path:    w.storage.GetImageURL(filename),
                Status:    "success",
                TraceID:   traceID,
        }

        // Publish result
        encoded, err := message.Encode(traceID, "image-fetcher", result)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = w.channel.Publish("", "image.processed", false, false, amqp.Publishing{
                ContentType: "application/json",
                Body:        encoded,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">log.Printf("Successfully processed image: %s -&gt; %s", url, result.S3Path)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package message

import (
        "encoding/json"
        "time"
)

type Envelope struct {
        TraceID   string          `json:"trace_id"`
        Source    string          `json:"source"`
        Timestamp time.Time       `json:"timestamp"`
        Payload   json.RawMessage `json:"payload"`
}

func Encode(traceID, source string, payload any) ([]byte, error) <span class="cov0" title="0">{
        body, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">env := Envelope{
                TraceID:   traceID,
                Source:    source,
                Timestamp: time.Now().UTC(),
                Payload:   body,
        }
        return json.Marshal(env)</span>
}

func Decode[T any](data []byte) (*Envelope, *T, error) <span class="cov0" title="0">{
        var env Envelope
        if err := json.Unmarshal(data, &amp;env); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">var payload T
        if err := json.Unmarshal(env.Payload, &amp;payload); err != nil </span><span class="cov0" title="0">{
                return &amp;env, nil, err
        }</span>
        <span class="cov0" title="0">return &amp;env, &amp;payload, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package rabbitmq

import (
        "log"
        "os"

        amqp "github.com/rabbitmq/amqp091-go"
)

func Connect() (*amqp.Connection, *amqp.Channel) <span class="cov0" title="0">{
        url := os.Getenv("RABBITMQ_URL")
        if url == "" </span><span class="cov0" title="0">{
                url = "amqp://guest:guest@rabbitmq:5672/"
        }</span>
        <span class="cov0" title="0">conn, err := amqp.Dial(url)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("RabbitMQ connect fail: %v", err)
        }</span>
        <span class="cov0" title="0">ch, err := conn.Channel()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("channel fail: %v", err)
        }</span>

        // Declare queues
        <span class="cov0" title="0">ch.QueueDeclare("image.urls", false, false, false, false, nil)
        ch.QueueDeclare("image.processed", false, false, false, false, nil)

        return conn, ch</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package tracing

import (
        "context"
        "log"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp"
        "go.opentelemetry.io/otel/sdk/resource"
        "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.4.0"
)

func Init(serviceName string) *trace.TracerProvider <span class="cov0" title="0">{
        // Create OTLP exporter for Jaeger
        exp, err := otlptracehttp.New(context.Background(),
                otlptracehttp.WithEndpoint("jaeger:4318"),
                otlptracehttp.WithInsecure(),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to create OTLP exporter: %v", err)
                // Fallback to stdout exporter for development
                return initStdoutTracer(serviceName)
        }</span>

        // Create resource with service information
        <span class="cov0" title="0">res, err := resource.New(context.Background(),
                resource.WithAttributes(
                        semconv.ServiceNameKey.String(serviceName),
                        semconv.ServiceVersionKey.String("1.0.0"),
                ),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to create resource: %v", err)
                res = resource.Default()
        }</span>

        // Create tracer provider
        <span class="cov0" title="0">provider := trace.NewTracerProvider(
                trace.WithBatcher(exp),
                trace.WithResource(res),
        )

        // Set global tracer provider
        otel.SetTracerProvider(provider)

        log.Printf("Tracing initialized for service: %s", serviceName)
        return provider</span>
}

func initStdoutTracer(serviceName string) *trace.TracerProvider <span class="cov0" title="0">{
        // Fallback to stdout exporter for development
        exp, _ := otlptracehttp.New(context.Background(),
                otlptracehttp.WithEndpoint("localhost:4318"),
                otlptracehttp.WithInsecure(),
        )

        res, _ := resource.New(context.Background(),
                resource.WithAttributes(
                        semconv.ServiceNameKey.String(serviceName),
                        semconv.ServiceVersionKey.String("1.0.0"),
                ),
        )

        provider := trace.NewTracerProvider(
                trace.WithBatcher(exp),
                trace.WithResource(res),
        )

        otel.SetTracerProvider(provider)
        log.Printf("Tracing initialized with fallback for service: %s", serviceName)
        return provider
}</span>

func Shutdown(provider *trace.TracerProvider) <span class="cov0" title="0">{
        if provider != nil </span><span class="cov0" title="0">{
                if err := provider.Shutdown(context.Background()); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error shutting down tracer provider: %v", err)
                }</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
